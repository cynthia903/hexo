title: "Git 分支管理流程"
date: 2015-08-31 22:31:51
updated: 2015-09-13 22:31:51
tags: Git
---

项目总归要协作开发，在此介绍团队中使用的工作流程。

# 分支管理流程

这里只介绍一个仓库，多个分支的情况。

## 创建特性分支

开发任务的第一个流程是创建特性分支，因为在分支上开发可以让你随意尝试，进退自如，比如碰上无法正常工作的补丁，可以先搁在那边，直到有时间仔细核查修复为止。

那么如何命名分支？可以用相关的主题关键字来命名分支，而且建议把分支名称分置于不同命名空间下，比如 cyn/python_cli 就说明这是 cyn 这个人贡献的。 

那么，开始创建第一个分支：

```bash
$ git checkout -b cyn/python_cli

do something...

$ git push origin cyn/python_cli
```

## 定期衍合

开发过程中，需要定期将最新的远程分支同步到本地分支，保持代码最新（up to date）：

```bash
$ git pull --rebase origin cyn/python_cli
```

加上 `--rebase` 的意思是: 

1. 把本地分支从上次 `pull` 之后的变更暂存起来；
2. 恢复到上次 `pull` 时的情况；
3. 合并远程分支的提交；
4. 最后再逐一合并刚暂存下来的本地提交（相当于重放一遍）。

由于远程分支和本地分支会同步地非常频繁，如果使用 `merge` 命令会造成线图（graph）无谓的复杂：

```
*   ab900eb - 三方合并版本（注意这里！）
|\
| * 756ba83 - 本地分支提交的版本
* | 915fe84 - 先被推送到远程分支的版本
|/
*   e7ce3f8 - 基准版本（共同祖先）
```

这时会推荐使用 `rebase` 避免无谓的合并节点，从而产生一个更为整洁的提交历史。如果视察一个衍合过的分支的历史记录，看起来会更清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。其线图如下：

```
*   dc6baf3 - 本地分支提交的版本（注意这个提交被改写了！）
|
*   915fe84 - 先被推送到远程分支的版本
|
*   e7ce3f8 - 基准版本（共同祖先）
```

解决衍合产生的冲突之后，推送到远程仓库：

```bash
$ git push origin cyn/python_cli
```

## 决断代码

特性分支开发完成之后，我们想要筛选并看清将要合并到主干的是哪些代码，从而理解它们到底做了些什么，是否真的要并入。可以用 `--not` 选项指定要屏蔽的分支 master，这样就会剔除重复的提交历史，看起来更清晰：

```bash
$ git log cyn/python_cli --not master
```

或者相反，使用 `..` 参数查看将要被合并到主干的提交：

```bash
$ git log master..cyn/python_cli
```

两者效果一致。

## 合并特性分支

现在，是时候将分支合并回主干，以便发布新版本了：

```bash
$ git checkout master
$ git merge --no-ff cyn/python_cli
```

注意，为了保证版本演进的清晰，分支合并回主干的操作建议加上 `--no-ff` 参数进行非快进式合并（no-fast-forward merge），以便保留合并痕迹。合并后的线图如下：

```
*   ab900eb - 合并版本（注意这里！）
|\
| * 756ba83 - 特性分支版本2
| * 915fe84 - 特性分支版本1
|/
*   e7ce3f8 - master 基准版本（祖先）
```

可以看见，合并后保留有分支历史痕迹，能看得出来曾经做过分支合并。为了保证版本演进的清晰，当分支合并到主干时，推荐使用！

同时作为对比，如果不加上 `--no-ff` 参数，合并后的线图如下：

```
*   756ba83 - 特性分支版本2（SHA-1 不变）
|
*   915fe84 - 特性分支版本1（SHA-1 不变）
|
*   e7ce3f8 - master 基准版本（祖先）
```

那么，究竟什么是快进式合并（fast-forward merge）？如果顺着一个分支走下去可以直接到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward））。

## 标记新版本

版本发布之后，应该标记该新版本，以便后续回滚到指定版本：

```bash
$ git tag -a v1.0 -m "XX 项目 v1.0 版本"
$ git push origin v1.0
```

注意，在默认情况下，`git push` 并不会把标签（tag）推送到远端仓库上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 `git push origin [tagname]` 即可。如果要一次推送所有本地新增的标签上去，可以使用 `--tags` 选项。

## 删除特性分支

最后是一些清理工作，删除已开发完成的分支，避免分支越来越多导致不好管理：

```bash
$ git push --delete origin cyn/python_cli
```

# 总结

## 衍合的目的与风险

* 一般我们使用衍合的目的，是想要得到一个能在远程分支上干净应用的补丁 — 比如某些项目你不是维护者，但想帮点忙的话，最好用衍合：先在自己的一个分支里进行开发，当准备向主项目提交补丁的时候，根据最新的 origin/master 进行一次衍合操作然后再提交，这样维护者就不需要做任何整合工作（实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决。），只需根据你提供的仓库地址作一次快进合并，或者直接采纳你提交的补丁。
* 衍合必须遵守的准则：**一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作。**如果把衍合当成一种在推送之前清理提交历史的手段，而且仅仅衍合那些尚未公开的提交对象，就没问题。如果衍合那些已经公开的提交对象，并且已经有人基于这些提交对象开展了后续开发工作的话，就会出现叫人沮丧的麻烦。

## 代码提交指南

* 请不要在更新中提交多余的白字符（whitespace）。Git 有种检查此类问题的方法，在提交之前，先运行 `git diff --check` ，会把可能的多余白字符修正列出来。
* 请将每次提交限定于完成一次逻辑功能。并且可能的话，适当地分解为多次小更新，以便每次小型提交都更易于理解。
* 最后需要谨记的是提交说明的撰写。可以理解为第一行的简要描述将用作邮件标题，其余部分作为邮件正文。

## 分支管理指南

* master 不提交代码，只合并代码。
* 合并代码到 master 的操作，由项目对应的集成管理员专人负责。
* 各分支要定期将 master 代码合并进来，避免后续分支合并到 master 时容易产生冲突，以减轻集成管理员的合并负担。
* 发版之后，要打 tag 。

# 参考

* 《[分布式 Git](https://git-scm.com/book/zh/v1/%E5%88%86%E5%B8%83%E5%BC%8F-Git)》
* 《[Git-分支-分支的衍合#衍合的风险](https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E8%A1%8D%E5%90%88#%E8%A1%8D%E5%90%88%E7%9A%84%E9%A3%8E%E9%99%A9)》
* 《[团队开发里频繁使用 git rebase 来保持树的整洁好吗?](http://segmentfault.com/q/1010000000430041)》
* 《[Git 分支管理策略 - 阮一峰](http://www.ruanyifeng.com/blog/2012/07/git.html)》
* 《[Git 分支管理策略 - 廖雪峰](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758410364457b9e3d821f4244beb0fd69c61a185ae0000)》